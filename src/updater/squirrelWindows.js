"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const electron_1 = require("electron");
const cp = require("child_process");
const fs = require("fs");
const path = require("path");
const productloader_1 = require("../util/productloader");
const Promise = require("bluebird");
const util = require("../util/util");
function initAsync() {
    setAppUserModelId();
    return handleSquirrelStartupEventsAsync();
}
exports.initAsync = initAsync;
function isFirstRun() {
    return process.argv[1] === "--squirrel-firstrun" /* FirstRun */;
}
exports.isFirstRun = isFirstRun;
function handleSquirrelStartupEventsAsync() {
    return new Promise((resolve, reject) => {
        if (process.platform !== "win32") {
            resolve();
            return;
        }
        const squirrelCommand = process.argv[1];
        switch (squirrelCommand) {
            case "--squirrel-install" /* Install */:
            case "--squirrel-updated" /* Updated */:
                util.retryAsync(overwriteExecutionStubAsync, 5)
                    .then(() => {
                    return updateShortcutsAsync(squirrelCommand === "--squirrel-install" /* Install */);
                })
                    .then(() => {
                    electron_1.app.quit();
                });
                return; // Don't resolve the promise; we don't want the app to continue running
            case "--squirrel-uninstall" /* Uninstall */:
                removeShortcutsAsync()
                    .then(() => {
                    clearAppData();
                    electron_1.app.quit();
                });
                return; // Don't resolve the promise; we don't want the app to continue running
            case "--squirrel-obsolete" /* Obsolete */:
                // No-op, just quit
                electron_1.app.quit();
                return; // Don't resolve the promise; we don't want the app to continue running
            default:
                resolve(); // Only resolve if there are no Squirrel events.
        }
    });
}
function setAppUserModelId() {
    // Squirrel Installer package id is "com.squirrel.PACKAGE_ID.EXE_WITHOUT_DOT_EXE"
    electron_1.app.setAppUserModelId(`com.squirrel.${electron_1.app.getName().replace(" ", "")}.${productloader_1.default.productName.replace(" ", "")}`);
}
/**
 * Squirrel.Windows has this concept of an "execution stub", which is an almost-empty executable that simply launches
 * the correct version of your Squirrel app. This execution stub is what all shortcuts point to, so it is essentially
 * the entry point of the app. The problem is that it is impossible to sign this executable at build time, because of
 * how Squirrel.Windows dynamically generates it.
 *
 * This function takes an execution stub that we manually created during the build (see our gulpfile / VSTS build for
 * more details), which is signed, and copies it over the one generated by Squirre.Windows. That way, we end up with a
 * signed execution stub in the right place.
 *
 * The execution stub is NOT invoked during install/update, so the net result is that we never run an unsigned
 * executable.
 */
function overwriteExecutionStubAsync() {
    const appRoot = path.dirname(process.execPath);
    const signedExecutionStubPath = path.join(appRoot, "resources", "app", "EXECUTION_STUB_REPLACE.exe");
    return util.fileExistsAsync(signedExecutionStubPath)
        .then((exists) => {
        if (exists) {
            const currentExecutionStub = path.join(appRoot, "..", `${productloader_1.default.productName}.exe`);
            return util.fsRenamePromise(signedExecutionStubPath, currentExecutionStub);
        }
        return Promise.resolve();
    });
}
function updateShortcutsAsync(isInstall) {
    const targetExe = path.basename(process.execPath);
    let args = "-l=StartMenu";
    if (isInstall) {
        args += ",Desktop";
    }
    else {
        try {
            if (fs.existsSync(path.join(electron_1.app.getPath("desktop"), `${productloader_1.default.productName}.lnk`))) {
                args = args + ",Desktop";
            }
        }
        catch (e) {
            // No-op; no shortcut to update
        }
    }
    return executeSquirrelCommandAsync([`--createShortcut=${targetExe}`, args]);
}
function removeShortcutsAsync() {
    const target = path.basename(process.execPath);
    return executeSquirrelCommandAsync(["--removeShortcut", target]);
}
function executeSquirrelCommandAsync(args) {
    return new Promise((resolve, reject) => {
        const updateDotExe = path.resolve(path.dirname(process.execPath), "..", "update.exe");
        const updateProcess = cp.spawn(updateDotExe, args, { cwd: path.resolve(path.dirname(process.execPath), ".."), detached: true });
        let executionError;
        updateProcess.on("close", (code) => {
            if (executionError) {
                reject(executionError);
            }
            else {
                resolve();
            }
        });
        updateProcess.on("error", (err) => {
            executionError = err;
        });
    });
}
function clearAppData() {
    return clearAppDataRecursive(electron_1.app.getPath('userData'));
}
function clearAppDataRecursive(rootPath) {
    fs.readdirSync(rootPath).forEach((file) => {
        const curPath = path.join(rootPath, file);
        if (fs.lstatSync(curPath).isDirectory()) {
            // Recurse
            return clearAppDataRecursive(curPath);
        }
        else {
            try {
                fs.unlinkSync(curPath);
            }
            catch (e) {
                // No-op
            }
        }
    });
    try {
        fs.rmdirSync(rootPath);
    }
    catch (e) {
        // No-op
    }
}
//# sourceMappingURL=squirrelWindows.js.map